--- ../src-base/minecraft/net/minecraft/world/gen/ChunkProviderServer.java
+++ ../src-work/minecraft/net/minecraft/world/gen/ChunkProviderServer.java
@@ -4,15 +4,11 @@
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
+import net.minecraft.block.BlockSand;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
@@ -21,22 +17,39 @@
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.EmptyChunk;
 import net.minecraft.world.chunk.IChunkGenerator;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.chunk.storage.AnvilChunkLoader;
 import net.minecraft.world.chunk.storage.IChunkLoader;
+import net.minecraftforge.common.ForgeChunkManager;
+import net.minecraftforge.common.chunkio.ChunkIOExecutor;
+import net.minecraftforge.fml.common.FMLCommonHandler;
+import net.minecraftforge.fml.common.FMLLog;
+import net.minecraftforge.fml.common.registry.GameRegistry;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Server;
+import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.craftbukkit.util.LongHashSet;
 
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.*;
+
+
 public class ChunkProviderServer implements IChunkProvider
 {
     private static final Logger LOGGER = LogManager.getLogger();
-    private final Set<Long> droppedChunksSet = Sets.<Long>newHashSet();
+    public final Set<Long> droppedChunksSet = Sets.<Long>newHashSet();
     public final IChunkGenerator chunkGenerator;
     public final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> id2ChunkMap = new Long2ObjectOpenHashMap(8192);
+    public final Long2ObjectOpenHashMap<Chunk> id2ChunkMap = new Long2ObjectOpenHashMap(8192);
     public final WorldServer worldObj;
     private Set<Long> loadingChunks = com.google.common.collect.Sets.newHashSet();
+    public boolean loadChunkOnProvideRequest = FMLCommonHandler.instance().getMinecraftServerInstance().svarkaConfig.loadChunkOnRequest.getValue(); // TODO Svarka - if true, allows mods to force load chunks. to disable, set load-chunk-on-request in cauldron.yml to false
 
+
     public ChunkProviderServer(WorldServer worldObjIn, IChunkLoader chunkLoaderIn, IChunkGenerator chunkGeneratorIn)
     {
         this.worldObj = worldObjIn;
@@ -60,8 +73,10 @@
 
     public void unloadAllChunks()
     {
-        for (Chunk chunk : this.id2ChunkMap.values())
+        Iterator<Chunk> iterator = this.id2ChunkMap.values().iterator();
+        while (iterator.hasNext())
         {
+            Chunk chunk = iterator.next();
             this.unload(chunk);
         }
     }
@@ -98,12 +113,13 @@
             {
                 if (!loadingChunks.add(pos)) net.minecraftforge.fml.common.FMLLog.bigWarning("There is an attempt to load a chunk (%d,%d) in dimension %d that is already being loaded. This will cause weird chunk breakages.", x, z, this.worldObj.provider.getDimension());
                 if (chunk == null) chunk = this.loadChunkFromFile(x, z);
+                AnvilChunkLoader loader = null;
 
                 if (chunk != null)
                 {
-                this.id2ChunkMap.put(ChunkPos.asLong(x, z), chunk);
-                chunk.onChunkLoad();
-                chunk.populateChunk(this, this.chunkGenerator);
+                    this.id2ChunkMap.put(ChunkPos.asLong(x, z), chunk);
+                    chunk.onChunkLoad();
+                    chunk.populateChunk(this, this.chunkGenerator);
                 }
 
                 loadingChunks.remove(pos);
@@ -122,8 +138,26 @@
             }
         }
 
+        /*AnvilChunkLoader loader = null;
+
+        if (this.chunkGenerator instanceof AnvilChunkLoader)
+        {
+            loader = (AnvilChunkLoader) this.chunkGenerator;
+        }
+        if (chunk == null && loader != null && loader.chunkExists(this.worldObj,x,z))
+        {
+            if(runnable != null){
+                ChunkIOExecutor.queueChunkLoad(this.worldObj, loader, this, x, z, runnable);
+                return null;
+            }else{
+                chunk = ChunkIOExecutor.syncChunkLoad(this.worldObj, loader, this, x, z);
+            }
+        } else if (chunk == null) {
+            chunk = this.provideChunk(x,z);
+        }
+
         // If we didn't load the chunk async and have a callback run it now
-        if (runnable != null) runnable.run();
+        if (runnable != null) runnable.run();*/
         return chunk;
     }
 
@@ -156,7 +190,51 @@
 
         return chunk;
     }
+    public void populate(IChunkProvider p_73153_1_, int p_73153_2_, int p_73153_3_)
+    {
+        Chunk chunk = this.provideChunk(p_73153_2_, p_73153_3_);
 
+        if (!chunk.isTerrainPopulated())
+        {
+            chunk.resetRelightChecks();
+
+            if (this.chunkGenerator != null)
+            {
+                this.chunkGenerator.populate(p_73153_2_, p_73153_3_);
+                // CraftBukkit start
+                BlockSand.fallInstantly = true;
+                Random random = new Random();
+                random.setSeed(worldObj.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) p_73153_2_ * xRand + (long) p_73153_3_ * zRand ^ worldObj.getSeed());
+                org.bukkit.World world = this.worldObj.getWorld();
+
+                if (world != null)
+                {
+                    this.worldObj.populating = true;
+
+                    try
+                    {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators())
+                        {
+                            populator.populate(world, random, chunk.bukkitChunk);
+                        }
+                    }
+                    finally
+                    {
+                        this.worldObj.populating = false;
+                    }
+                }
+
+                BlockSand.fallInstantly = false;
+                this.worldObj.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                // CraftBukkit end
+                GameRegistry.generateWorld(p_73153_2_, p_73153_3_, worldObj, this.chunkGenerator, p_73153_1_);
+                chunk.setChunkModified();
+            }
+        }
+    }
     @Nullable
     private Chunk loadChunkFromFile(int x, int z)
     {
