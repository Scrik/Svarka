--- ../src-base/minecraft/net/minecraft/item/ItemStack.java
+++ ../src-work/minecraft/net/minecraft/item/ItemStack.java
@@ -9,6 +9,7 @@
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockMushroom;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.enchantment.Enchantment;
 import net.minecraft.enchantment.EnchantmentDurability;
@@ -20,6 +21,8 @@
 import net.minecraft.entity.ai.attributes.AttributeModifier;
 import net.minecraft.entity.item.EntityItemFrame;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.init.Blocks;
 import net.minecraft.init.Enchantments;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.EntityEquipmentSlot;
@@ -45,6 +48,11 @@
 import net.minecraft.world.World;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.Location;
+import org.bukkit.TreeType;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Player;
+import org.bukkit.event.world.StructureGrowEvent;
 
 public final class ItemStack implements net.minecraftforge.common.capabilities.ICapabilitySerializable<NBTTagCompound>
 {
@@ -54,7 +62,8 @@
     private Item item;
     private NBTTagCompound stackTagCompound;
     int itemDamage;
-    private EntityItemFrame itemFrame;
+    private transient EntityItemFrame itemFrame;
+    public static EntityPlayer currentPlayer; // Cauldron - reference to current player calling onItemUse
     private Block canDestroyCacheBlock;
     private boolean canDestroyCacheResult;
     private Block canPlaceOnCacheBlock;
@@ -101,8 +110,15 @@
         {
             this.itemDamage = 0;
         }
+        sizeCheck(this);
     }
 
+    private static void sizeCheck(ItemStack itemStack) {
+        if(itemStack.stackSize < -1){
+            itemStack.stackSize = 0;
+        }
+    }
+
     public static ItemStack loadItemStackFromNBT(NBTTagCompound nbt)
     {
         if (nbt.hasNoTags()) return null; // Deserialized inventories can have empty ItemStack compounds. Fixes tons of NumberFormatExceptions
@@ -142,9 +158,53 @@
 
     public EnumActionResult onItemUse(EntityPlayer playerIn, World worldIn, BlockPos pos, EnumHand hand, EnumFacing side, float hitX, float hitY, float hitZ)
     {
-        if (!worldIn.isRemote) return net.minecraftforge.common.ForgeHooks.onPlaceItemIntoWorld(this, playerIn, worldIn, pos, side, hitX, hitY, hitZ, hand);
+        // CraftBukkit start - handle all block place event logic here
+        //if (!worldIn.isRemote) return net.minecraftforge.common.ForgeHooks.onPlaceItemIntoWorld(this, playerIn, worldIn, pos, side, hitX, hitY, hitZ, hand);
+        int data = this.getMetadata();
+        int count = this.stackSize;
+        if(!(this.getItem() instanceof ItemBucket)){
+            worldIn.captureBlockStates = true;
+            // special case bonemeal
+            if(this.getItem() instanceof ItemDye && this.getMetadata() == 15){
+                Block block = worldIn.getBlockState(pos).getBlock();
+                if(block == Blocks.SAPLING || block instanceof BlockMushroom){
+                    worldIn.captureTreeGeneration = true;
+                }
+            }
+        }
         EnumActionResult enumactionresult = this.getItem().onItemUse(this, playerIn, worldIn, pos, hand, side, hitX, hitY, hitZ);
+        int newData = this.getMetadata();
+        int newCount = this.stackSize;
+        this.stackSize = count;
+        //this.set(data);
+        /*worldIn.captureBlockStates = false;
+        if (enumactionresult == EnumActionResult.SUCCESS && worldIn.captureTreeGeneration && worldIn.capturedBlockStates.size() > 0) {
+            worldIn.captureTreeGeneration = false;
+            Location location = new Location(worldIn.getWorld(), pos.getX(), pos.getY(), pos.getZ());
+            *//*TreeType treeType = Blocks.SAPLING.treeType;
+            BlockSapling.treeType = null;*//*
+            List<BlockState> blocks = (List<BlockState>) worldIn.capturedBlockStates.clone();
+            worldIn.capturedBlockStates.clear();
+            StructureGrowEvent event = null;
+            if (treeType != null) {
+                boolean isBonemeal = getItem() == Items.DYE && data == 15;
+                event = new StructureGrowEvent(location, treeType, isBonemeal, (Player) playerIn.getBukkitEntity(), blocks);
+                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            }
+            if (event == null || !event.isCancelled()) {
+                // Change the stack to its new contents if it hasn't been tampered with.
+                if (this.stackSize == count && this.getMetadata() == data) {
+                    //this.setData(newData);
+                    this.stackSize = newCount;
+                }
+                for (BlockState blockstate : blocks) {
+                    blockstate.update(true);
+                }
+            }
 
+            return enumactionresult;
+        }
+        worldIn.captureTreeGeneration = false;*/
         if (enumactionresult == EnumActionResult.SUCCESS)
         {
             playerIn.addStat(StatList.getObjectUseStats(this.item));
@@ -160,6 +220,7 @@
 
     public ActionResult<ItemStack> useItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand hand)
     {
+        sizeCheck(this);
         return this.getItem().onItemRightClick(this, worldIn, playerIn, hand);
     }
 
@@ -172,13 +233,14 @@
     public NBTTagCompound writeToNBT(NBTTagCompound nbt)
     {
         ResourceLocation resourcelocation = (ResourceLocation)Item.REGISTRY.getNameForObject(this.item);
+        sizeCheck(this);
         nbt.setString("id", resourcelocation == null ? "minecraft:air" : resourcelocation.toString());
         nbt.setByte("Count", (byte)this.stackSize);
         nbt.setShort("Damage", (short)this.itemDamage);
 
         if (this.stackTagCompound != null)
         {
-            nbt.setTag("tag", this.stackTagCompound);
+            nbt.setTag("tag", this.stackTagCompound.copy());
         }
 
         if (this.capabilities != null)
@@ -202,10 +264,11 @@
         {
             this.itemDamage = 0;
         }
+        sizeCheck(this);
 
         if (nbt.hasKey("tag", 10))
         {
-            this.stackTagCompound = nbt.getCompoundTag("tag");
+            this.stackTagCompound = nbt.getCompoundTag("tag").copy();
 
             if (this.item != null)
             {
@@ -217,11 +280,13 @@
 
     public int getMaxStackSize()
     {
+        sizeCheck(this);
         return this.getItem().getItemStackLimit(this);
     }
 
     public boolean isStackable()
     {
+        sizeCheck(this);
         return this.getMaxStackSize() > 1 && (!this.isItemStackDamageable() || !this.isItemDamaged());
     }
 
@@ -260,8 +325,10 @@
         return this.item == null ? 0 : this.item.getMaxDamage(this);
     }
 
-    public boolean attemptDamageItem(int amount, Random rand)
-    {
+    public boolean attemptDamageItem(int amount, Random rand) {
+        return attemptDamageItem(amount, rand, null);
+    }
+    public boolean attemptDamageItem(int amount, Random rand, EntityLivingBase entityLivingBase){
         if (!this.isItemStackDamageable())
         {
             return false;
@@ -282,7 +349,22 @@
                 }
 
                 amount -= j;
+                // Spigot start //TODO
+/*                if (entityLivingBase instanceof EntityPlayerMP)
+                {
+                    org.bukkit.craftbukkit.inventory.CraftItemStack item = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
+                    org.bukkit.event.player.PlayerItemDamageEvent event = new org.bukkit.event.player.PlayerItemDamageEvent(
+                            (org.bukkit.entity.Player) entityLivingBase.getBukkitEntity(), item, amount);
+                    org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
 
+                    if (event.isCancelled())
+                    {
+                        return false;
+                    }
+
+                    amount = event.getDamage();
+                }*/
+                // Spigot end
                 if (amount <= 0)
                 {
                     return false;
@@ -300,7 +382,7 @@
         {
             if (this.isItemStackDamageable())
             {
-                if (this.attemptDamageItem(amount, entityIn.getRNG()))
+                if (this.attemptDamageItem(amount, entityIn.getRNG(), entityIn))
                 {
                     entityIn.renderBrokenItemStack(this);
                     --this.stackSize;
@@ -310,10 +392,10 @@
                         EntityPlayer entityplayer = (EntityPlayer)entityIn;
                         entityplayer.addStat(StatList.getObjectBreakStats(this.item));
                     }
-
-                    if (this.stackSize < 0)
+                    sizeCheck(this);
+                    if (this.stackSize == 0 && entityIn instanceof EntityPlayer)
                     {
-                        this.stackSize = 0;
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerItemBreakEvent((EntityPlayer)entityIn,this);
                     }
 
                     this.itemDamage = 0;
@@ -354,6 +436,7 @@
 
     public ItemStack copy()
     {
+        sizeCheck(this);
         ItemStack itemstack = new ItemStack(this.item, this.stackSize, this.itemDamage, this.capabilities != null ? this.capabilities.serializeNBT() : null);
 
         if (this.stackTagCompound != null)
@@ -1075,4 +1158,11 @@
             return this.capabilities.areCompatible(other.capabilities);
         }
     }
+    // Spigot start
+    public static boolean fastMatches(ItemStack is1, ItemStack is2) {
+        if (is1 == null && is2 == null) return true;
+        if (is1 != null && is2 != null) return is1.stackSize == is2.stackSize && is1.item == is2.item && is1.itemDamage == is2.itemDamage;
+        return false;
+    }
+    // Spigot end
 }
